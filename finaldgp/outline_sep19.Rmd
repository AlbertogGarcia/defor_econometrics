---
title: "deforestation econometrics results outline"
#author: "Alberto Garcia"
#date: "September 3, 2019"
#updated: "October 1, 2019"
output:
  pdf_document:
    number_sections: yes
    toc: no
fontsize: 11pt    
documentclass: article
geometry: margin=1in
header-includes: 
  \usepackage{sectsty}
  \usepackage{enumitem}
  \usepackage{comment}
  \usepackage{multirow,array}
  \usepackage{makecell}
  \usepackage{amsmath}
  \usepackage{amsfonts} 
  \usepackage{amssymb} 
  \usepackage{graphicx} 
  \usepackage{float} 
  \usepackage{bbm} 
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)

#landscape maps
source('landscape_maps.R')

#binary fcns
source('quickmontey.R')
source('quickmontey_did.R')
source('binary_coeffdist_fcn.R')
source('funcform.R')

#aggregated fcns
source('grid_scapegen.R')
source('outcome_comparison.R')
source('county_scapegen.R')
source('county_sims.R')
source('aggregation_method.R')
source('weightingarea.R')

source('xy_agg_ATT.R')
source('xy_proppert.R')

```
\sectionfont{\fontsize{11}{11}\selectfont}
\subsectionfont{\fontsize{11}{11}\selectfont}

Define universal parameters
```{r parameters}
set.seed(930)

base_0 = .02
base_1 = .04
trend = -.005
ATT = -.01

std_a = 0.1
std_v = 0.25
years = 3
nobs = 10000
n = 500

cellsize = 10
ppoints = 50
std_p = 0
cpoints = 20

```

```{r generating beta parameters, results='hide', warning = FALSE}

std_av = (std_a^2+std_v^2)^.5
b0 = qnorm(base_0, mean = 0, sd = std_av)
b1 = qnorm(base_1, mean = 0, sd = std_av) - b0
b2 = qnorm(trend + base_0, mean = 0, sd = std_av) - b0
b3 = qnorm( pnorm(b0+b1+b2, mean = 0, sd = std_av) + ATT , mean = 0, sd = std_av) - (b0 + b1 + b2)

```

```{r parameters csv, results='hide', warning = FALSE}

parameter <- c('ATT', 'baseline_0','baseline_1','trend')
value <- c(ATT, base_0, base_1, trend)

param_table <- data.frame(parameter, value)
write.csv(param_table, "param_table.csv")


expost_treat <- base_1+trend + ATT
expost_untreat <- base_0+trend
single_diff <- expost_treat-expost_untreat
simple_table <- data.frame(expost_treat, expost_untreat, single_diff, ATT)
write.csv(simple_table, "simple_table.csv")


treatment <- c("intervention area", "intervention area", "untreated area", "untreated area")
period <- factor(c("pre-intervention", "post-intervention", "pre-intervention", "post-intervention"), levels = c("pre-intervention", "post-intervention"))
defor <- c(base_1,
           (base_1+trend+ATT),
           base_0,
           (base_0+trend)
)
bar_df <- data.frame(treatment, period, defor)
bar_df$lab <- paste(bar_df$defor, paste("(",bar_df$defor*100,"%)",sep=""),sep=" ")

ggplot(bar_df, aes(fill=period, y=lab, x=treatment)) + 
  geom_bar(stat="identity", position=position_dodge2(reverse = TRUE))+
  #geom_text(aes(x = treatment, y=lab,label=lab),vjust=0) +
  theme(legend.title = element_blank()) +
  ylab("Annual deforestation rate (%)") + xlab("")
ggsave(path = "landscape_figs", filename = "barchart.png", dpi = 500)

```



## initial DID estimates

```{r DIDy, results='hide', warning = FALSE}
DID_y <- quickmontey(n, nobs, years, b0, b1, b2, b3, std_a, std_v, "y")
DID_y$plot

ggsave(path = "figs", filename = "fig1.png", dpi = 500)


```

We begin by allowing the outcome to vary between 0 and 1 across time periods.  We see a slight bias in the DID estimates of the ATT when there exist both a time trend and a group difference in the baseline deforestation rates. This result stems from the fact that the DID estimand does not identify the ATT with the nonlinearity introduced in the DGP. The bias generated is on average `r mean(DID_y$did_biases$V1)`, which represents a bias of `r abs(DID_y$prop_ATT)*100` \% of the ATT. 



```{r DIDy1, results='hide', warning = FALSE}
DID_keep <- quickmontey_did(n, nobs, years, b0, b1, b2, b3, std_a, std_v, "defor")
DID_keep$plot

ggsave(path = "figs", filename = "fig2.png", dpi = 500)


```


We will now drop pixels in the periods after they first become deforested. 

```{r DIDy_it, results='hide', warning = FALSE}
#dropping obs from panel in periods after they first become deforested
DID_drop <- quickmontey_did(n, nobs, years, b0, b1, b2, b3, std_a, std_v, "y_it")
DID_drop$plot

#ggsave(path = "figs", filename = "fig3.png", dpi = 500)


```

## two-way fixed effects vs. simple DID

We'll now address the use of two-way fixed effects and the dropping of observations in the periods after pixels are first observed as deforested. The magnitude of the bias is smallest using the basic DID. Note that the DID and 2way fixed effects estimates are identical when observations are not dropped. As we show in our proof, in the general case, using 2 way fixed effects dropping the observations yields the ATT plus the difference between the treated and untreated groups. The DID on the other hand should identify the ATT. 

```{r FE, results='hide', warning = FALSE}
twowayFE <- binary_coeffdist_fcn(n, nobs, years, b0, b1, b2, b3, std_a, std_v)
twowayFE$plot

ggsave(path = "figs", filename = "twowayFE.png", dpi = 500)

binary_results <- twowayFE$binary_results

```


## functional form test (logit, probit, vs. DID)


```{r functionalforms, results='hide', warning = FALSE}
functionalform <- funcform(n, nobs, years, b0, b1, b2, b3, std_a, std_v)
#functionalform$plot

#ggsave(path = "figs", filename = "functionalform.png", dpi = 500)
  
func_results <- functionalform$func_results 
write.csv(func_results, "func_results.csv")

```

The above plot shows the DID bias depending on functional form decisions. 


# Aggregating pixels

## various outcomes wheen aggregating

We now aggregate to the grid level. Below, we see the bias introduced by using different outcome variables and specifications commonly used in the literature. (Need a table here to show the different outcomes and will want to cite different papers that use these outcomes)

\begin{center}
\begin{tabular}{ |c|c|c|c|c| } 
 \hline
 number & outcome & additional covariates & model type & paper \\ 
 \hline
 1 & $\frac{F_{it-1} - F_{it}}{F_{it-1}} $ & & Two-way FE& Busch et al. 2015; Carlson et al. 2018, Shah and Baylis 2015 \\ 
 2 & $\frac{F_{i0} - F_{it}}{F_{i0}} $ &  & Two-way FE & Pfaff 1999
\\ 
 3 & $\frac{F_{it-1} - F_{it}}{F_{i0}} $& & Two-way FE & \\ 
 \hline
\end{tabular}
\end{center}

```{r outcomes, results='hide', warning = FALSE}

outcomes <- outcome_comparison(100, nobs, years, b0, b1, b2, b3, std_a, std_v, cellsize)
outcomes$plot

#ggsave(path = "figs", filename = "outcomes.png", dpi = 500)
outcome_results <- outcomes$outcome_results 
write.csv(outcome_results, "outcome_results.csv")

```


## aggregating to county, property, and grid levels
 
Moving forward, we use the first outcome from above, as it generated the least bias. We consider three possible aggregation methods: county, property, and grid level in order to look at the distribution of the estimates. At this point we also introduce property level perturbations into the DGP. 



```{r aggregate, results = 'hide', warning=FALSE}
aggregation <- aggregation_method(n, nobs, years, b0, b1, b2, b3, std_a, std_v, std_p, cellsize, ppoints, cpoints)
aggregation$plot

#ggsave(path = "figs", filename = "aggregation.png", dpi = 500)

agg_biases <- aggregation$biases
#write.csv(agg_biases, "agg_biases.csv")


coverages_df <- aggregation$coverages_df
#write.csv(coverages_df, "coverages.csv")

agg_results <- aggregation$agg_results


results_df <- binary_results %>%
  bind_rows(agg_results)
```





```{r generating parameters with std_p, results = 'hide', warning=FALSE}
std_p1 = 0.15
  
std_avp = (std_a^2 + std_v^2 + std_p1)^.5
b0 = qnorm(base_0, mean = 0, sd = std_avp)
b1 = qnorm(base_1, mean = 0, sd = std_avp) - b0
b2 = qnorm(trend + base_0, mean = 0, sd = std_avp) - b0
b3 = qnorm( pnorm(b0+b1+b2, mean = 0, sd = std_avp) + ATT , mean = 0, sd = std_avp) - (b0 + b1 + b2)

```


```{r property unobservables, results = 'hide', warning=FALSE}
prop_aggreg <- aggregation_method(n, nobs, years, b0, b1, b2, b3, std_a, std_v, std_p1, cellsize, ppoints, cpoints)
prop_aggreg$plot

#ggsave(path = "figs", filename = "aggregation.png", dpi = 500)

coverages_properror_df <- prop_aggreg$coverages_df

# write.csv(coverages_properror_df, "coverages_p15.csv")
```


```{r landscape maps period one, warning=FALSE}
landscape_map <- landscape_maps(nobs, years = 1, b0, b1, b2, b3, std_a, std_v, std_p, cellsize, ppoints, cpoints)

landscape_map$landscape_time
ggsave(path = "landscape_figs", filename = "landscape_did.png", dpi = 500)


```

```{r landscape maps counterfactual, warning=FALSE}
landscape_map$landscape_period2_counter

ggsave(path = "landscape_figs", filename = "counterfactual.png", dpi = 500)

```

```{r landscape maps period two nolegend, warning=FALSE}
landscape_map$landscape_period2_nolegend
ggsave(path = "landscape_figs", filename = "period2_nolegend.png", dpi = 500)

```

## Weighting the regression

Interestingly, we note that upon weighting the regression aggregated to the property level, the distribution is significantly wider. This also appears to happen with the regression aggregated to the county level, but not nearly to the same extent. Weighting the regression aggregated to the grid level has almost no impact. This makes intuitive sense, since the grids are all of equal size. We see a larger impact of weighting the regressions in the property and county cases, because there is more area heterogeneity across units. 

```{r weighting, results='hide', warning=FALSE}
weighting <- weightingarea(n, nobs, years, b0, b1, b2, b3, std_a, std_v, std_p, cellsize, ppoints, cpoints)
weighting$plot

ggsave(path = "figs", filename = "weighting.png", dpi = 500)

```

```{r parameters2}
set.seed(930)

base_0 = .05
base_1 = .02
trend = .005
ATT = .01


std_av = (std_a^2+std_v^2)^.5
b0 = qnorm(base_0, mean = 0, sd = std_av)
b1 = qnorm(base_1, mean = 0, sd = std_av) - b0
b2 = qnorm(trend + base_0, mean = 0, sd = std_av) - b0
b3 = qnorm( pnorm(b0+b1+b2, mean = 0, sd = std_av) + ATT , mean = 0, sd = std_av) - (b0 + b1 + b2)

```

```{r binary2, results='hide', warning = FALSE}
twowayFE2 <- binary_coeffdist_fcn(n, nobs, years, b0, b1, b2, b3, std_a, std_v)
twowayFE2$plot

binary_results2 <- twowayFE2$binary_results
```

```{r outcomes2, results='hide', warning = FALSE}

outcomes2 <- outcome_comparison(100, nobs, years, b0, b1, b2, b3, std_a, std_v, cellsize)
outcomes2$plot

#ggsave(path = "figs", filename = "outcomes.png", dpi = 500)
outcome_results2 <- outcomes2$outcome_results 
write.csv(outcome_results2, "outcome_results2.csv")
```

```{r functionalforms2, results='hide', warning = FALSE}
functionalform2 <- funcform(n, nobs, years, b0, b1, b2, b3, std_a, std_v)

#dropping obs from panel in periods after they first become deforested

func_results2 <- functionalform2$func_results 
write.csv(func_results2, "func_results2.csv")
```

```{r aggregate, results = 'hide', warning=FALSE}
aggregation2 <- aggregation_method(n, nobs, years, b0, b1, b2, b3, std_a, std_v, std_p, cellsize, ppoints, cpoints)

coverages_df2 <- aggregation2$coverages_df
#write.csv(coverages_df, "coverages.csv")

agg_results2 <- aggregation2$agg_results


results_df2 <- binary_results2 %>%
  bind_rows(agg_results2)
```

```{r property unobservables 2, results = 'hide', warning=FALSE}
prop_aggreg2 <- aggregation_method(n, nobs, years, b0, b1, b2, b3, std_a, std_v, std_p1, cellsize, ppoints, cpoints)

coverages_properror_df2 <- prop_aggreg2$coverages_df

```


```{r parameters3}
set.seed(930)

base_0 = .02
base_1 = .05
trend = .01
ATT = -.03


std_av = (std_a^2+std_v^2)^.5
b0 = qnorm(base_0, mean = 0, sd = std_av)
b1 = qnorm(base_1, mean = 0, sd = std_av) - b0
b2 = qnorm(trend + base_0, mean = 0, sd = std_av) - b0
b3 = qnorm( pnorm(b0+b1+b2, mean = 0, sd = std_av) + ATT , mean = 0, sd = std_av) - (b0 + b1 + b2)

```


```{r binary3, results='hide', warning = FALSE}
twowayFE3 <- binary_coeffdist_fcn(n, nobs, years, b0, b1, b2, b3, std_a, std_v)
twowayFE3$plot

binary_results3 <- twowayFE3$binary_results
```

```{r outcomes3, results='hide', warning = FALSE}

outcomes3 <- outcome_comparison(100, nobs, years, b0, b1, b2, b3, std_a, std_v, cellsize)
outcomes3$plot

#ggsave(path = "figs", filename = "outcomes.png", dpi = 500)
outcome_results3 <- outcomes3$outcome_results 
write.csv(outcome_results3, "outcome_results3.csv")
```


```{r functionalforms3, results='hide', warning = FALSE}
functionalform3 <- funcform(n, nobs, years, b0, b1, b2, b3, std_a, std_v)

#dropping obs from panel in periods after they first become deforested

func_results3 <- functionalform3$func_results 
write.csv(func_results3, "func_results3.csv")
```

```{r aggregate3, results = 'hide', warning=FALSE}
aggregation3 <- aggregation_method(n, nobs, years, b0, b1, b2, b3, std_a, std_v, std_p, cellsize, ppoints, cpoints)

coverages_df3 <- aggregation3$coverages_df
#write.csv(coverages_df, "coverages.csv")

agg_results3 <- aggregation3$agg_results


results_df3 <- binary_results3 %>%
  bind_rows(agg_results3)
```

```{r property unobservables 2, results = 'hide', warning=FALSE}
prop_aggreg3 <- aggregation_method(n, nobs, years, b0, b1, b2, b3, std_a, std_v, std_p1, cellsize, ppoints, cpoints)

coverages_properror_df3 <- prop_aggreg2$coverages_df

```


